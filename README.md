## Experimental 3D engine using vanilla javascript and HTML5 canvas
- I wrote my own matrix and vector libraries to better understand how it all works with the idea that eventually I will be able to make really cool, complex animations.
- Simply writing functions that remove the matrix calculations would be more efficient, but for now, learning wins!
- This is set up with the goal of being able to easily integrate an interactive front end.

To get started:
- npm install raf and jquery

## Modules
  1. Vector Operations - vector3d.js, vector2d.js
    - Small library for simple vector operations for 2d and 3d coordinates.
    - Vector3D.transformCoordinates - multiplies a vector by the transformation matrix. This is needed for the final step of the matrix calculations needed to rotate an object.

  2. Matrix Calculations - matrix.js
    - Matrix constructor starts with a matrix pre-filled with zeros. To do calculations, new matrices are generated by resetting the indices in the initial array.
    - Matrix.LookatLH - generates a new matrix resulting from the camera object 'looking at' the mesh
    - Matrix.PerspectiveLH - generates a new matrix to show perspective
    - Matrix.PerspectiveFovLH - generates a new matrix taking parameters (field of view, aspect ratio, closest distance from the camera and furthest distance from the camera (represented by z value))
    - Matrix.Translation - generates a new matrix that moves all points by specified values
    - Matrix.rotationYPR - generates the final rotation matrix, which is the result of multiplying rotational matrices about the x, y and z axis. (yaw, pitch and roll are just aeronautical terms to denote rotation about x, y and z axes).

  3. Meshes - iso.js, cube.js
    - Outlines coordinates in 3d space.

  4. Main Program - entry.js
    - We set up the Mesh, Camera and Device objects
    - Mesh - has properties vertices, rotation and center
    - Cameria - has initial properties position (camera location), target(what the camera is looking at) and up(where the top of the camera is pointing)
    - Device - sets up canvas
        1. Clear - clear canvas between each frame
        2. Project - takes 3d coordinates, applies all matrix operations, and projects them on to the 2D canvas.
        3. drawPoint - draws each vertex of each mesh
        4. Render - sets up all 3d operations
          - Get View Matrix using camera position, target and up vectors
          - Get Projection Matrix by calculating perspective using the f-value, aspect ratio, and near nad far
          - Loop through all meshes in the mesh array
          - Get World Matrix by multiplying the Final Rotation Matrix by the Translation Matrix
          - Get Transform matrix by multiplying the View Matrix by the Projection Matrix
          - For each vertex in the current mesh project 3D coordinates into the 2D space
          - Draw each projected vertex on the 2D canvas
